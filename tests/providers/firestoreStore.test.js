// tests/providers/firestoreStore.test.js
const FirestoreStore = require('../../src/providers/FirestoreStore');
const Project = require('../../src/models/Project');
const Objective = require('../../src/models/Objective');
const { Firestore, Timestamp } = require('@google-cloud/firestore');

// Mock the Firestore client
jest.mock('@google-cloud/firestore');

describe('FirestoreStore.js', () => {
    let store;
    let mockFirestoreInstance;
    let mockCollection;
    let mockDoc;
    let mockQuery;
    let mockSnapshot;

    const MOCK_GCLOUD_PROJECT_ID = 'test-gcp-project';
    const MOCK_KEY_FILENAME = '/path/to/fake/keyfile.json';

    beforeEach(() => {
        // Reset all mocks for Firestore
        mockDoc = {
            set: jest.fn().mockResolvedValue({}),
            get: jest.fn(),
            update: jest.fn().mockResolvedValue({}),
            delete: jest.fn().mockResolvedValue({}),
        };
        mockQuery = {
            where: jest.fn().mockReturnThis(),
            get: jest.fn(),
        };
        mockCollection = {
            doc: jest.fn().mockReturnValue(mockDoc),
            get: jest.fn(), // For getAll
            where: jest.fn().mockReturnValue(mockQuery), // For getByProjectId
            add: jest.fn(), // Not typically used if IDs are client-generated
        };
        mockSnapshot = {
            docs: [],
            empty: true,
        };
        mockQuery.get.mockResolvedValue(mockSnapshot); // Default for queries
        mockCollection.get.mockResolvedValue(mockSnapshot); // Default for getAll

        mockFirestoreInstance = {
            collection: jest.fn().mockReturnValue(mockCollection),
            listCollections: jest.fn().mockResolvedValue([]), // For connectivity check
            batch: jest.fn().mockReturnThis(),
            commit: jest.fn().mockResolvedValue([]),
            runTransaction: jest.fn(),
        };

        // Configure the Firestore constructor mock
        Firestore.mockImplementation(() => mockFirestoreInstance);

        store = new FirestoreStore(MOCK_GCLOUD_PROJECT_ID, MOCK_KEY_FILENAME);

        // Assertions for constructor
        expect(Firestore).toHaveBeenCalledWith({
            projectId: MOCK_GCLOUD_PROJECT_ID,
            keyFilename: MOCK_KEY_FILENAME,
        });
        expect(mockFirestoreInstance.collection).toHaveBeenCalledWith('projects');
        expect(mockFirestoreInstance.collection).toHaveBeenCalledWith('objectives');
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('Connection (Conceptual)', () => {
        test('loadData should attempt a Firestore operation to confirm connectivity', async () => {
            await store.loadData();
            expect(mockFirestoreInstance.listCollections).toHaveBeenCalledTimes(1);
        });

        test('loadData should throw if connectivity check fails', async () => {
            mockFirestoreInstance.listCollections.mockRejectedValueOnce(new Error('Connection failed'));
            await expect(store.loadData()).rejects.toThrow('Connection failed');
        });
    });

    describe('Project Operations', () => {
        const projectData = { name: 'Firestore Project', description: 'A test project' };
        let projectInstance;

        beforeEach(() => {
            projectInstance = new Project(projectData.name, projectData.description);
        });

        test('addProject should set a project document using project ID', async () => {
            const result = await store.addProject(projectData); // projectData doesn't have ID yet

            // The instance created inside addProject will have an ID
            const callArg = mockDoc.set.mock.calls[0][0];
            expect(mockCollection.doc).toHaveBeenCalledWith(expect.any(String)); // ID is generated by Project model
            expect(mockDoc.set).toHaveBeenCalledTimes(1);
            expect(callArg.name).toBe(projectData.name);
            expect(callArg.createdAt).toBeInstanceOf(Timestamp);

            expect(result.name).toBe(projectData.name);
            expect(result.id).toBeDefined();
        });

        test('getAllProjects should retrieve and map all projects', async () => {
            const projectDoc1Data = { name: 'P1', description: 'D1', createdAt: Timestamp.now(), updatedAt: Timestamp.now() };
            const projectDoc2Data = { name: 'P2', description: 'D2', createdAt: Timestamp.now(), updatedAt: Timestamp.now() };
            mockCollection.get.mockResolvedValue({
                docs: [
                    { id: 'p1', data: () => projectDoc1Data, exists: true },
                    { id: 'p2', data: () => projectDoc2Data, exists: true },
                ],
                empty: false,
            });

            const results = await store.getAllProjects();
            expect(mockCollection.get).toHaveBeenCalledTimes(1);
            expect(results).toHaveLength(2);
            expect(results[0]).toBeInstanceOf(Project);
            expect(results[0].name).toBe('P1');
            expect(results[0].id).toBe('p1');
        });

        test('findProjectById should retrieve and map a project', async () => {
            const projectId = 'uniqueProjectId';
            const projectDocData = { name: 'Found Project', description: 'Desc', createdAt: Timestamp.now(), updatedAt: Timestamp.now() };
            mockDoc.get.mockResolvedValue({ id: projectId, data: () => projectDocData, exists: true });

            const result = await store.findProjectById(projectId);
            expect(mockCollection.doc).toHaveBeenCalledWith(projectId);
            expect(mockDoc.get).toHaveBeenCalledTimes(1);
            expect(result).toBeInstanceOf(Project);
            expect(result.name).toBe('Found Project');
            expect(result.id).toBe(projectId);
        });
         test('findProjectById should return null if project does not exist', async () => {
            const projectId = 'nonExistentId';
            mockDoc.get.mockResolvedValue({ exists: false });

            const result = await store.findProjectById(projectId);
            expect(mockCollection.doc).toHaveBeenCalledWith(projectId);
            expect(result).toBeNull();
        });


        test('updateProjectById should update the project document', async () => {
            const projectId = 'projToUpdate';
            const updatePayload = { name: 'Updated Name' };
            // For returning the updated doc
            const updatedData = { name: 'Updated Name', description: 'Original Desc', updatedAt: Timestamp.now() };
            mockDoc.get.mockResolvedValue({ id: projectId, data: () => updatedData, exists: true });


            const result = await store.updateProjectById(projectId, updatePayload);
            expect(mockCollection.doc).toHaveBeenCalledWith(projectId);
            expect(mockDoc.update).toHaveBeenCalledWith(expect.objectContaining({
                name: 'Updated Name',
                updatedAt: expect.any(Timestamp)
            }));
            expect(result.name).toBe('Updated Name');
        });

        test('deleteProjectById should remove project and its objectives', async () => {
            const projectId = 'projToDelete';
            // Simulate objectives for this project
             mockQuery.get.mockResolvedValue({
                docs: [
                    { id: 'obj1', ref: 'objectives/obj1', data: () => ({ projectId }), exists: true },
                    { id: 'obj2', ref: 'objectives/obj2', data: () => ({ projectId }), exists: true },
                ],
                empty: false,
            });
            // Mock batch operations
            const mockBatchDelete = jest.fn();
            mockFirestoreInstance.batch = jest.fn(() => ({
                delete: mockBatchDelete,
                commit: jest.fn().mockResolvedValue({})
            }));


            const success = await store.deleteProjectById(projectId);

            expect(mockObjectivesCollection.where).toHaveBeenCalledWith('projectId', '==', projectId);
            expect(mockQuery.get).toHaveBeenCalledTimes(1); // For objectives
            expect(mockFirestoreInstance.batch).toHaveBeenCalledTimes(1); // Batch for deleting objectives
            expect(mockBatchDelete).toHaveBeenCalledTimes(2); // Two objectives deleted
            expect(mockProjectsCollection.doc).toHaveBeenCalledWith(projectId); // For project itself
            expect(mockDoc.delete).toHaveBeenCalledTimes(1); // Project deleted
            expect(success).toBe(true);
        });
    });

    describe('Objective Operations', () => {
        const projectId = 'parentProjectId';
        const objectiveData = { title: 'Firestore Objective', brief: 'A test objective' };

        beforeEach(() => {
            // Mock findProjectById to return a project for addObjective
            const parentProjectData = { name: 'Parent', description: 'Parent Desc', createdAt: Timestamp.now(), updatedAt: Timestamp.now() };
            const parentDocRefMock = {
                get: jest.fn().mockResolvedValue({ id: projectId, data: () => parentProjectData, exists: true })
            };
            mockProjectsCollection.doc.mockImplementation(id => {
                if (id === projectId) return parentDocRefMock;
                return mockDoc; // Default mockDoc for other IDs
            });
        });

        test('addObjective should set an objective document', async () => {
            const result = await store.addObjective(objectiveData, projectId);

            const callArg = mockDoc.set.mock.calls[0][0];
            expect(mockObjectivesCollection.doc).toHaveBeenCalledWith(expect.any(String)); // ID generated by Objective model
            expect(mockDoc.set).toHaveBeenCalledTimes(1);
            expect(callArg.title).toBe(objectiveData.title);
            expect(callArg.projectId).toBe(projectId);
            expect(callArg.createdAt).toBeInstanceOf(Timestamp);
            expect(result.title).toBe(objectiveData.title);
        });

        test('addObjective should throw error if project not found', async () => {
            // Make findProjectById return null
            const nonExistentParentDocRefMock = {
                get: jest.fn().mockResolvedValue({ exists: false })
            };
            mockProjectsCollection.doc.mockImplementation(id => {
                 if (id === 'nonExistentProjectId') return nonExistentParentDocRefMock;
                 return mockDoc;
            });

            await expect(store.addObjective(objectiveData, 'nonExistentProjectId'))
                .rejects
                .toThrow('Project with ID nonExistentProjectId not found. Cannot add objective.');
        });

        test('getObjectivesByProjectId should query and map objectives', async () => {
            const obj1Data = { title: 'O1', brief: 'B1', projectId, createdAt: Timestamp.now(), updatedAt: Timestamp.now() };
            mockQuery.get.mockResolvedValue({
                docs: [{ id: 'o1', data: () => obj1Data, exists: true }],
                empty: false,
            });

            const results = await store.getObjectivesByProjectId(projectId);
            expect(mockObjectivesCollection.where).toHaveBeenCalledWith('projectId', '==', projectId);
            expect(mockQuery.get).toHaveBeenCalledTimes(1);
            expect(results).toHaveLength(1);
            expect(results[0].title).toBe('O1');
        });

        test('addMessageToObjectiveChat should use a transaction to update chat history', async () => {
            const objectiveId = 'objWithChat';
            const initialChatData = { title: 'Chat Obj', chatHistory: [], updatedAt: Timestamp.now() };

            // Mock the transaction
            mockFirestoreInstance.runTransaction.mockImplementation(async (updateFunction) => {
                // Simulate the transaction's get
                const mockObjectiveSnapshot = {
                    exists: true,
                    data: () => initialChatData, // Provide initial data for the transaction
                };
                const mockTransaction = {
                    get: jest.fn().mockResolvedValue(mockObjectiveSnapshot),
                    update: jest.fn(), // This will be called by the updateFunction
                };
                await updateFunction(mockTransaction); // Execute the callback passed to runTransaction
                // Assertions on mockTransaction.update can be done here if needed
                expect(mockTransaction.update).toHaveBeenCalledWith(
                    mockDoc, // docRef for objectiveId
                    expect.objectContaining({
                        chatHistory: [expect.objectContaining({ speaker: 'user', content: 'Hello Firestore' })],
                        updatedAt: expect.any(Timestamp)
                    })
                );

            });
            // Ensure the docRef passed to the transaction is correct
             mockObjectivesCollection.doc.mockReturnValue(mockDoc);


            const message = await store.addMessageToObjectiveChat(objectiveId, 'user', 'Hello Firestore');

            expect(mockFirestoreInstance.runTransaction).toHaveBeenCalledTimes(1);
            expect(message.content).toBe('Hello Firestore');
            expect(message.speaker).toBe('user');
            expect(message.timestamp).toBeInstanceOf(Date);
        });
    });
});
